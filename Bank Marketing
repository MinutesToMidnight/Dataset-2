import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.metrics import f1_score
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from imblearn.over_sampling import SMOTE


def load_data(path_to_file: str):
    return pd.read_csv(path_to_file, sep=';')


def preprocess(df):
    categorial_columns = ["job", "marital", "education", "contact", "month", "poutcome"]
    binary_columns = ["default", "housing", "loan"]

    for col in binary_columns:
        df[col] = df[col].map({'yes': 1, 'no': 0})

    df['y'] = df['y'].map({'yes': 1, 'no': 0})

    X = df.drop(columns=["y"])
    y = df["y"]

    numeric_columns = list(set(X.columns) - set(categorial_columns) - set(binary_columns))

    scaler = StandardScaler()
    encoder = OneHotEncoder()
    preprocessor = ColumnTransformer(
        transformers=[
            ('num', scaler, numeric_columns),
            ('cat', encoder, categorial_columns),
            ('bin', 'passthrough', binary_columns)
        ]
    )

    X = preprocessor.fit_transform(X)
    mean_value = np.nanmean(X)
    X = np.where(np.isnan(X), mean_value, X)

    smote = SMOTE()
    X, y = smote.fit_resample(X, y)

    return X, y, preprocessor, numeric_columns


def train(X, y, model):
    X = torch.tensor(X, dtype=torch.float32)
    y = torch.tensor(y, dtype=torch.long)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    model.train()
    criterion = nn.CrossEntropyLoss(weight=torch.tensor([1.0, 20.0]))
    optimizer = optim.Adam(model.parameters(), lr=0.01)
    for epoch in range(10):
        for x_tr, y_tr in zip(X_train, y_train):
            predict = model(x_tr)
            loss = criterion(predict, y_tr)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
    return X_test, y_test


def evaluate(X_test, y_test, model, y_size):
    model.eval()

    # Инициализация матрицы ошибок
    confusion_matrix = [[0] * y_size for _ in range(y_size)]
    Q = 0
    predictions = []

    with torch.no_grad():
        for x_t, y_t in zip(X_test, y_test):
            predict = model(x_t)
            predict = torch.argmax(predict)
            predictions.append(predict)
            confusion_matrix[predict][y_t] += 1
            Q += predict == y_t

    print(f"Accuracy: {Q / len(y_test) * 100}%")
    print(f"\nConfusion matrix:")
    for index, line in enumerate(confusion_matrix):
        print(index, *line)

    # Преобразование предсказаний и истинных меток в CPU и numpy
    predictions = torch.tensor(predictions, dtype=torch.long).cpu().numpy()
    y_test_cpu = y_test.cpu().numpy()

    print(f"F1-score: {f1_score(predictions, y_test_cpu)}")


def hist(df, numeric_columns):
    # Построение столбчатых диаграмм для каждого числового параметра с разделением по классам на одном графике
    for column in numeric_columns:
        plt.figure(figsize=(10, 5))
        sns.histplot(data=df, x=column, hue='y', multiple='stack', palette='coolwarm')
        plt.xlabel('Частота появления')
        plt.ylabel(column)
        plt.title(f'Столбчатая диаграмма для {column} с разделением по классам')
        plt.show()


def boxplot(df, numeric_columns):
    for column in numeric_columns:
        plt.figure(figsize=(10, 5))
        sns.boxplot(x='y', y=column, data=df, palette='coolwarm')
        plt.title(f'Ящик с усами для {column} по классам')
        plt.xlabel('Класс')
        plt.ylabel(column)
        plt.show()


if __name__ == "__main__":
    path_to_file = "D:/Python/Python Projects/PycharmProjects/bank-full.csv"
    df = load_data(path_to_file)
    X, y, preprocessor, numeric_columns = preprocess(df)
    # hist(df, numeric_columns)
    # boxplot(df, numeric_columns)
    y_size = len(set(y))
    model = nn.Sequential(nn.Linear(X[1].size, y_size))
    X_test, y_test = train(X, y, model)
    evaluate(X_test, y_test, model, y_size)
